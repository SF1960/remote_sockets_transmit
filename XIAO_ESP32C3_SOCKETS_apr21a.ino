/* Revision History
*
* 1.0 Original Working Version
*
*/

/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/7f2ffa43-f5e7-4316-b9cf-fff48fb4292d 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int socket_1_enable; OFF,ON,AUTO
  int socket_2_enable; OFF,ON,AUTO
  int socket_3_enable; OFF,ON,AUTO
  CloudSchedule socket_1_schedule_morning;
  CloudSchedule socket_2_schedule_morning;
  CloudSchedule socket_3_schedule_morning;
  bool socket_1; ON, OFF
  bool socket_2; ON, OFF
  bool socket_3; ON, OFF

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

/***************************************************************************************
* Description:  ESP32 NOW and Arduino IOT sketches
* Sketch:       XIAO_ESP32C3_SOCKETS_apr21a.ino
* Version:      1.0
* Version Desc: This is the working code for ESP32_NOW and Arduino IOT
* Board:        ESP32 based boards
* Author:       Steve Fuller
* Website:      
* Comments:     If the ESP32 return Callback: Delivery Fail it is probably becuase your
*               Wifi is not set to Channel 1. Go to http://192.168.1.1/2.0/gui/#/login/
****************************************************************************************/

/*******************************************************************************************************
* debug_print routine that replaces Serial.Print() and therefore does not get compiled
* Set to DEBUG to 1 to print to the serial monitor. When you are happy with the code set DEBUG to 0
* Thanks to Ralph S Bacon https://youtu.be/--KxxMaiwSE
********************************************************************************************************/
#define DEBUG 0 

#if DEBUG == 1
  #define debug_print(x)   Serial.print(x)
  #define debug_println(x) Serial.println(x)
#else
  #define debug_print(x)
  #define debug_println(x)
#endif

#include "arduino_secrets.h"                         // Internet and controller details
#include "thingProperties.h"                         // library handled by Arduino IOT
#include <esp_now.h>                                 // ESP_NOW library
#include <WiFi.h>                                    // WiFi library
#include <WiFiManager.h>                             // to allow the user to log on to their own network

#define BAUD 115200                                  // Serial port baud rate

// Variables for transmitted data
bool bool_value = true;                              // Power On or OFF
int int_socket;                                      // Socket Number
char result;                                         // result of send
#define OFF 0
#define ON 1
#define AUTO 2

// MAC Address of responder - edit as required;
// for list of my ESP32 MAC Addresses goto;
// https://docs.google.com/spreadsheets/d/1zeHhUQ800quf7LlVyviluqHowV3Big6YN5qjG9SoFbc/edit#gid=0

// Set up MAC addresses for socket controllers
uint8_t broadcastAddress_1[] = {0x7C, 0x87, 0xCE, 0x30, 0x8D, 0x0C}; // ESP32 #14 socket 1
uint8_t broadcastAddress_2[] = {0x94, 0xB5, 0x55, 0xF8, 0x30, 0x70}; // ESP32 #8  socket 2 94:B5:55:F8:30:70
uint8_t broadcastAddress_3[] = {0x7C, 0x87, 0xCE, 0x30, 0x91, 0xCC}; // ESP32 #16 socket 3

// Define a data structure to transmit;
typedef struct socket_message {
  bool socket_state;                                 // On or Off
  int socket_number;                                 // which socket 1 to 3
} socket_message;

// Create a structured object based on struct_message
socket_message myData;

// Peer info
esp_now_peer_info_t peerInfo;

// Callback function called when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  debug_print("\r\nLast Packet Send Status:\t");
  debug_println(status == ESP_NOW_SEND_SUCCESS ? "Callback: Delivery Success" : "Callback: Delivery Fail");
}

// function that prints the data send result and socket number
void print_result(String result_text, int socket_number){
  debug_print("Socket "); debug_print(socket_number);debug_print(" ");debug_println(result_text);
}

// main set up routine
void setup() {

  Serial.begin(BAUD);                                 // Initialize serial and wait for port to open:              
  delay(1500);                                        // This delay gives the chance to wait for a Serial Monitor without blocking if none is found

  debug_println("Setup Started");

  initProperties();                                   // Defined in thingProperties.h

  ArduinoCloud.begin(ArduinoIoTPreferredConnection);  // Connect to Arduino IoT Cloud
  
  /*
    The following function allows you to obtain more information
    related to the state of network and IoT Cloud connection and errors
    the higher number the more granular information youâ€™ll get.
    The default is 0 (only errors).
    Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // Set ESP32 as a Wi-Fi Station. Select your wifi and add credentials
  WiFiManager wm;                                    // set WiFiManager object
  //wm.resetSettings();                                // remove comment to force on on everytime

  // Define a text box, 50 characters maximum
  WiFiManagerParameter custom_text_box("my_text", "Enter your channel here", "1", 50);
  wm.addParameter(&custom_text_box);                 // Add custom parameter to the WiFi log on page

  bool res;
  res = wm.autoConnect("Socket_WiFi");               // Select this access point on your device and follow instructions
  if (!res) {
    debug_println("Failed to connect.");
    ESP.restart();
  }

  // set the channel number from the user WiFi
  String strChannel_number = custom_text_box.getValue();
  int intChannel_number = strChannel_number.toInt();
  debug_print("Channel Number: "); debug_println(intChannel_number);

  WiFi.mode(WIFI_AP_STA);                            // Set up WiFi in station mode
  // wait a second
  delay(1000);

  // added this line to try and get around the WiFi Channel changing from the default 1
  WiFi.disconnect();

  // Initilize ESP-NOW
  if (esp_now_init() != ESP_OK) {
    debug_println("Error initializing ESP-NOW");
    return;
  }

  // Register the send callback function
  esp_now_register_send_cb(OnDataSent);

  // register each controller peer
  peerInfo.channel = intChannel_number;              // this is set manually when logging into user's WiFi
  peerInfo.encrypt = false;                          // data is sent unencrypted

  // register first peer  
  memcpy(peerInfo.peer_addr, broadcastAddress_1, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    debug_println("Failed to add peer 1");
    return;
  }
  // register second peer  
  memcpy(peerInfo.peer_addr, broadcastAddress_2, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    debug_println("Failed to add peer 2");
    return;
  }
  // register third peer
  memcpy(peerInfo.peer_addr, broadcastAddress_3, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    debug_println("Failed to add peer 3");
    return;
  }

  // App peers with error messages
  String Return_Text;
  switch (esp_now_add_peer(&peerInfo)) {
    case ESP_OK:
      Return_Text = "ESP 32 Peer Succesfully Added";
      break;
    case ESP_ERR_ESPNOW_NOT_INIT:
      Return_Text = "ESP32 Device Not Initialised";
      break;
    case ESP_ERR_ESPNOW_FULL:
      Return_Text = "ESP NOW Device List Full";
      break;
    case ESP_ERR_ESPNOW_NO_MEM:
      Return_Text = "MEMORY FULL";
      break;
  }

  debug_println(Return_Text);                       // Print Peer Connection Message

  // set the IOT variables 
  socket_1 = false;
  socket_2 = false;
  socket_3 = false;

  debug_println("Setup Complete");

} // setup()

void loop() {

  ArduinoCloud.update();
  delay(100);
  // loop through checking the status of the lighting control
  // 0 = OFF. 1 = ON. 2 = AUTO (Use the schedule)
  // check the status of each socket and act accordingly
  switch(socket_1_enable){
    
    case 0: // OFF

      debug_print("Socket 1 Enable is OFF: ");
      socket_1 = false;
      onSocket1Change();                            // force the socket OFF when enable is OFF and user clicks ON
      break;

    case 1: // ON

      debug_print("Socket 1  Enable is ON: ");
      // allow manual control of socket
      break;

    case 2: // AUTO

      debug_print("Socket 1 Enable is AUTO: ");

        if (socket_1_schedule_morning.isActive()){

          debug_print("Socket 1 in AUTO and Active");
          socket_1 = true;
          onSocket1Change();                        // force the socket OFF when schedule is OFF and user clicks ON

        } else {

          debug_print("Socket 1 in AUTO and Inactive");
          socket_1 = false;
          onSocket1Change();                        // force the socket OFF when schedule is OFF and user clicks ON

        }

      break;

    default:
      break;
    
  } // switch case socket_1_enable

  switch(socket_2_enable){
    
    case 0: // OFF

      debug_print("Socket 2 Enable is OFF: ");
      socket_2 = false;
      onSocket2Change();                            // force the socket OFF when enable is OFF and user clicks ON
      break;

    case 1: // ON

      debug_print("Socket 2 Enable is ON: ");
      // allow manual control of socket
      break;

    case 2: // AUTO

      debug_print("Socket 2 Enable is AUTO: ");

        if (socket_2_schedule_morning.isActive()){

          debug_print("Socket 2 in AUTO and Active");
          socket_2 = true;
          onSocket2Change();                        // force the socket OFF when schedule is OFF and user clicks ON

        } else {

          debug_print("Socket 2 in AUTO and Inactive");
          socket_2 = false;
          onSocket2Change();                        // force the socket OFF when schedule is OFF and user clicks ON

        }

      break;

    default:
      break;
    
  } // switch case socket_2_enable

  switch(socket_3_enable){
    
    case 0: // OFF

      debug_println("Socket 3 Enable is OFF: ");
      socket_3 = false;
      onSocket3Change();                            // force the socket OFF when enable is OFF and user clicks ON
      break;

    case 1: // ON

      debug_println("Socket 3 Enable is ON: ");
      // allow manual control of socket
      break;

    case 2: // AUTO

      debug_println("Socket 3 Enable is AUTO: ");

        if (socket_3_schedule_morning.isActive()){

          debug_println("Socket 3 in AUTO and Active");
          socket_3 = true;
          onSocket3Change();                        // force the socket OFF when schedule is OFF and user clicks ON

        } else {

          debug_println("Socket 3 in AUTO and Inactive");
          socket_3 = false;
          onSocket3Change();                        // force the socket OFF when schedule is OFF and user clicks ON

        }

      break;

    default:                                        // do nothing
      break;
    
  } // switch case socket_3_enable

} // loop()

/*
  These functions switch on and off sockets depending in its ID number
*/
void onSocket1Change()  {
  // Add your code here to act upon Socket1 change

  myData.socket_number = 1;                          // set the socket number
    
  if (socket_1 && (socket_1_enable == ON || socket_1_enable == AUTO)){  // ignore if enable == OFF

    myData.socket_state =  true;                     // socket on 
    debug_println("Socket 1 ON"); 

  } else { 

    myData.socket_state =  false;                    // socket off
    debug_println("Socket 1 OFF"); 

  }

  esp_err_t result = esp_now_send(broadcastAddress_1, (uint8_t *) &myData, sizeof(myData));

  if (result == ESP_OK) { 

    debug_print("Sending Confirmed"); debug_println(myData.socket_number); 
    } else { 
    debug_print("Sending Error"); debug_println(myData.socket_number); 
    
  }

delay(10);
  
} // onSocket1Change()

void onSocket2Change()  {
  // Add your code here to act upon Socket2 change

  myData.socket_number = 2;                          // set the socket number

  if (socket_2 && (socket_2_enable == ON || socket_2_enable == AUTO)){   // socket 2 ON IF in Manual

    myData.socket_state =  true;                     // socket on
    debug_println("Socket 2 ON"); 

  } else { 

    myData.socket_state =  false;                    // socket off
    debug_println("Socket 2 OFF"); 

  }

  esp_err_t result = esp_now_send(broadcastAddress_2, (uint8_t *) &myData, sizeof(myData));

  if (result == ESP_OK) { 

    debug_print("Sending Confirmed"); debug_println(myData.socket_number); 
    } else { 
    debug_print("Sending Error"); debug_println(myData.socket_number); 
    
  }

delay(10);

} // onSocket2Change()

void onSocket3Change()  {
  // Add your code here to act upon Socket3 change

  myData.socket_number = 3;                          // set the socket number

  if (socket_3 && (socket_3_enable == ON || socket_3_enable == AUTO)){    // socket 3 ON IF in Manual

    myData.socket_state =  true;                     // socket on 
    debug_println("Socket 3 ON"); 

  } else { 

    myData.socket_state =  false;                    // socket off
    debug_println("Socket 3 OFF"); 

  }

  esp_err_t result = esp_now_send(broadcastAddress_3, (uint8_t *) &myData, sizeof(myData));

  if (result == ESP_OK) { 

    debug_print("Sending Confirmed"); debug_println(myData.socket_number); 
    } else { 
    debug_print("Sending Error"); debug_println(myData.socket_number); 

  }

delay(10);

} // onSocket3Change()


/*
  Since Socket1Enable is READ_WRITE variable, onSocket1EnableChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSocket1EnableChange()  {
  // Add your code here to act upon Socket1Enable change
}
/*
  Since Socket1ScheduleMorning is READ_WRITE variable, onSocket1ScheduleMorningChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSocket1ScheduleMorningChange()  {
  // Add your code here to act upon Socket1ScheduleMorning change
}
/*
  Since Socket2ScheduleMorning is READ_WRITE variable, onSocket2ScheduleMorningChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSocket2ScheduleMorningChange()  {
  // Add your code here to act upon Socket2ScheduleMorning change
}
/*
  Since Socket3ScheduleMorning is READ_WRITE variable, onSocket3ScheduleMorningChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSocket3ScheduleMorningChange()  {
  // Add your code here to act upon Socket3ScheduleMorning change
}

/*
  Since Socket2Enable is READ_WRITE variable, onSocket2EnableChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSocket2EnableChange()  {
  // Add your code here to act upon Socket2Enable change
}

/*
  Since Socket3Enable is READ_WRITE variable, onSocket3EnableChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSocket3EnableChange()  {
  // Add your code here to act upon Socket3Enable change
}